=head1 NAME

XML::Compile::WSDL11 - create SOAP messages defined by WSDL 1.1

=head1 INHERITANCE

 XML::Compile::WSDL11
   is a XML::Compile::Cache
   is a XML::Compile::Schema
   is a XML::Compile

=head1 SYNOPSIS

 # preparation
 use XML::Compile::WSDL11;      # use WSDL version 1.1
 use XML::Compile::SOAP11;      # use SOAP version 1.1
 use XML::Compile::Transport::SOAPHTTP;

 my $wsdl = XML::Compile::WSDL11->new($wsdlfile);
 $wsdl->addWSDL(...more WSDL files...);
 $wsdl->importDefinitions(...more schemas...);

 # during initiation, for each used call (slow)
 my $call = $wsdl->compileClient('GetStockPrice', ...);

 # at "run-time", call as often as you want (fast)
 my $answer = $call->(%request);

 # capture useful trace information
 my ($answer, $trace) = $call->(%request);

 # when you like, get all operation definitions
 my @all_ops = $wsdl->operations;

 # Install XML::Compile::SOAP::Daemon
 my $server  = XML::Compile::SOAP::HTTPDaemon->new;
 $server->actionsFromWSDL($wsdl);
 
 # For debug info, start your script with:
 use Log::Report mode => 'DEBUG';

=head1 DESCRIPTION

This module implements WSDL version 1.1.
An WSDL file defines a set of messages to be send and received over
(SOAP) connections.

As end-user, you do not have to worry about the complex details of the
messages and the way to exchange of them: it's all simple Perl for you.
Also faults are handled automatically.  The only complication you have
to worry about, is to shape a nested HASH structure to the sending
message structure.  L<XML::Compile::Schema::template()|XML::Compile::Schema/"Compilers"> may help you.

When the definitions are spread over multiple files, you will need to
use L<addWSDL()|XML::Compile::WSDL11/"Extension"> (wsdl), or L<importDefinitions()|XML::Compile::Schema/"Administration"> (additional schema's)
explicitly, because L<XML::Compile::Schema|XML::Compile::Schema> does not wish dynamic internet
download magic to happen.

=head1 METHODS

=head2 Constructors

XML::Compile::WSDL11-E<gt>B<new>(XML, OPTIONS)

=over 4

The XML is the WSDL file, which is anything accepted by
L<XML::Compile::dataToXML()|XML::Compile/"Compilers">.  All options are also passed
to create an internal L<XML::Compile::Schema|XML::Compile::Schema> object.  See
L<XML::Compile::Schema::new()|XML::Compile::Schema/"Constructors">

 Option            --Defined in     --Default
 allow_undeclared    XML::Compile::Cache  <false>
 any_element         XML::Compile::Cache  'SKIP_ALL'
 block_namespace     XML::Compile::Schema  []
 hook                XML::Compile::Schema  undef
 hooks               XML::Compile::Schema  []
 ignore_unused_tags  XML::Compile::Schema  <false>
 key_rewrite         XML::Compile::Schema  []
 opts_readers        XML::Compile::Cache  []
 opts_rw             XML::Compile::Cache  []
 opts_writers        XML::Compile::Cache  []
 prefixes            XML::Compile::Cache  <smart>
 schema_dirs         XML::Compile     undef
 typemap             XML::Compile::Schema  {}

. allow_undeclared => BOOLEAN

. any_element => CODE|'TAKE_ALL'|'SKIP_ALL'|'ATTEMPT'|'SLOPPY'

. block_namespace => NAMESPACE|TYPE|HASH|CODE|ARRAY

. hook => ARRAY-WITH-HOOKDATA | HOOK

. hooks => ARRAY-OF-HOOK

. ignore_unused_tags => BOOLEAN|REGEXP

. key_rewrite => HASH|CODE|ARRAY-of-HASH-and-CODE

. opts_readers => HASH|ARRAY-of-PAIRS

. opts_rw => HASH|ARRAY-of-PAIRS

. opts_writers => HASH|ARRAY-of-PAIRS

. prefixes => HASH|ARRAY-of-PAIRS

. schema_dirs => DIRECTORY|ARRAY-OF-DIRECTORIES

. typemap => HASH

=back

=head2 Accessors

$obj-E<gt>B<addHook>(HOOKDATA|HOOK|undef)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<addHooks>(HOOK, [HOOK, ...])

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<addKeyRewrite>(PREDEF|CODE|HASH, ...)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<addSchemaDirs>(DIRECTORIES|FILENAME)

XML::Compile::WSDL11-E<gt>B<addSchemaDirs>(DIRECTORIES|FILENAME)

=over 4

See L<XML::Compile/"Accessors">

=back

$obj-E<gt>B<addSchemas>(XML, OPTIONS)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<addTypemap>(PAIR)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<addTypemaps>(PAIRS)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<allowUndeclared>([BOOLEAN])

=over 4

See L<XML::Compile::Cache/"Accessors">

=back

$obj-E<gt>B<blockNamespace>(NAMESPACE|TYPE|HASH|CODE|ARRAY)

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<hooks>

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

$obj-E<gt>B<prefix>(PREFIX)

=over 4

See L<XML::Compile::Cache/"Accessors">

=back

$obj-E<gt>B<prefixFor>(URI)

=over 4

See L<XML::Compile::Cache/"Accessors">

=back

$obj-E<gt>B<prefixed>(TYPE)

=over 4

See L<XML::Compile::Cache/"Accessors">

=back

$obj-E<gt>B<prefixes>([PAIRS|ARRAY|HASH])

=over 4

See L<XML::Compile::Cache/"Accessors">

=back

$obj-E<gt>B<useSchema>(SCHEMA, [SCHEMA])

=over 4

See L<XML::Compile::Schema/"Accessors">

=back

=head2 Compilers

$obj-E<gt>B<compile>(('READER'|'WRITER'), TYPE, OPTIONS)

=over 4

See L<XML::Compile::Schema/"Compilers">

=back

$obj-E<gt>B<compileAll>(['READER'|'WRITER'|'RW', [NAMESPACE]])

=over 4

See L<XML::Compile::Cache/"Compilers">

=back

XML::Compile::WSDL11-E<gt>B<dataToXML>(NODE|REF-XML-STRING|XML-STRING|FILENAME|FILEHANDLE|KNOWN)

=over 4

See L<XML::Compile/"Compilers">

=back

$obj-E<gt>B<reader>(TYPE|NAME, OPTIONS)

=over 4

See L<XML::Compile::Cache/"Compilers">

=back

$obj-E<gt>B<template>('XML'|'PERL', TYPE, OPTIONS)

=over 4

See L<XML::Compile::Schema/"Compilers">

=back

$obj-E<gt>B<writer>(TYPE|NAME)

=over 4

See L<XML::Compile::Cache/"Compilers">

=back

=head2 Administration

$obj-E<gt>B<declare>('READER'|'WRITER'|'RW', TYPE|ARRAY-of-TYPES, OPTIONS)

=over 4

See L<XML::Compile::Cache/"Administration">

=back

$obj-E<gt>B<elements>

=over 4

See L<XML::Compile::Schema/"Administration">

=back

$obj-E<gt>B<findName>(NAME)

=over 4

See L<XML::Compile::Cache/"Administration">

=back

$obj-E<gt>B<findSchemaFile>(FILENAME)

XML::Compile::WSDL11-E<gt>B<findSchemaFile>(FILENAME)

=over 4

See L<XML::Compile/"Administration">

=back

$obj-E<gt>B<importDefinitions>(XMLDATA, OPTIONS)

=over 4

See L<XML::Compile::Schema/"Administration">

=back

$obj-E<gt>B<knownNamespace>(NAMESPACE|PAIRS)

XML::Compile::WSDL11-E<gt>B<knownNamespace>(NAMESPACE|PAIRS)

=over 4

See L<XML::Compile/"Administration">

=back

$obj-E<gt>B<namespaces>

=over 4

See L<XML::Compile::Schema/"Administration">

=back

$obj-E<gt>B<types>

=over 4

See L<XML::Compile::Schema/"Administration">

=back

$obj-E<gt>B<walkTree>(NODE, CODE)

=over 4

See L<XML::Compile/"Administration">

=back

=head2 Extension

$obj-E<gt>B<addWSDL>(XMLDATA)

=over 4

Some XMLDATA, accepted by L<XML::Compile::dataToXML()|XML::Compile/"Compilers"> is provided,
which should represent the top-level of a (partial) WSDL document.
The specification can be spread over multiple files, which each have a
C<definition> root element.

=back

$obj-E<gt>B<compileClient>([NAME], OPTIONS)

=over 4

Creates temporarily an L<XML::Compile::Operation|XML::Compile::Operation> object with
L<operation()|XML::Compile::WSDL11/"Extension">, and then calls C<compileClient()> on that; an usual
combination.

As OPTIONS are available the combination of all possibilities for

=over 4

=item .

L<operation()|XML::Compile::WSDL11/"Extension"> (i.e. C<service> and C<port>), and all of

=item .

L<XML::Compile::Operation::compileClient()|XML::Compile::Operation/"Handlers"> (a whole lot,
for instance C<transport_hook> and C<server>), plus

=item .

everything you can pass to L<XML::Compile::Schema::compile()|XML::Compile::Schema/"Compilers">, for
instance C<< check_values => 0 >>, hooks, and typemaps.

=back

example: 

  $wsdl->compileClient
    ( operation => 'HelloWorld'
    , port      => 'PrefillSoap' # only needed when multiple ports
    , sloppy_integers => 1       # X::C::compile() option
    );

=back

$obj-E<gt>B<namesFor>(CLASS)

=over 4

Returns the list of names available for a certain definition
CLASS in the WSDL.

=back

$obj-E<gt>B<operation>([NAME], OPTIONS)

=over 4

Collect all information for a certain operation.  Returned is an
L<XML::Compile::Operation|XML::Compile::Operation> object.

An operation is defined by a service name, a port, some bindings,
and an operation name, which can be specified explicitly and often
left-out (in any situation where there are no alternative choices).

When not specified explicitly via OPTIONS, each of the CLASSes are only
permitted to have exactly one definition.  Otherwise, you must make a
choice explicitly.  There is a very good reason to be not too flexible
in this area: developers need to be aware when there are choices, where
some flexibility is required.

 Option   --Default
 action     <undef>
 operation  <required>
 port       <only when just one>
 service    <only when just one>

. action => STRING

=over 4

Overrule the soapAction from the WSDL.

=back

. operation => NAME

=over 4

Ignored when the parameter list starts with a NAME (which is an
alternative for this option).  Optional when there is only
one operation defined within the portType.

=back

. port => NAME

=over 4

Required when more than one port is defined.

=back

. service => QNAME

=over 4

Required when more than one service is defined.

=back

=back

=head2 Introspection

All of the following methods are usually NOT meant for end-users. End-users
should stick to the L<operation()|XML::Compile::WSDL11/"Extension"> and L<compileClient()|XML::Compile::WSDL11/"Extension"> methods.

$obj-E<gt>B<findDef>(CLASS, [QNAME|NAME])

=over 4

With a QNAME, the HASH which contains the parsed XML information
from the WSDL template for that CLASS-NAME combination is returned.
Otherwise, NAME is considered to be the localName in that class.
When the NAME is not found, an error is produced.

Without QNAME in SCALAR context, there may only be one such name
defined otherwise an error is produced.  In LIST context, all definitions
in CLASS are returned.

=back

$obj-E<gt>B<index>([CLASS, [QNAME]])

=over 4

With a CLASS and QNAME, it returns one WSDL definition HASH or undef.
Returns the index for the CLASS group of names as HASH.  When no CLASS is
specified, a HASH of HASHes is returned with the CLASSes on the top-level.

=back

$obj-E<gt>B<operations>(OPTIONS)

=over 4

Return a list with all operations defined in the WSDL.

 Option --Default
 binding  <undef>
 port     <undef>
 service  <undef>

. binding => NAME

=over 4

Only return operations which use the binding with the specified NAME.
By default, all bindings are accepted.

=back

. port => NAME

=over 4

Return only operations related to the specified port NAME.
By default operations from all ports.

=back

. service => NAME

=over 4

Only return operations related to the NAMEd service, by default all services.

=back

=back

$obj-E<gt>B<printIndex>([FILEHANDLE], OPTIONS)

=over 4

For available OPTIONS, see L<operations()|XML::Compile::WSDL11/"Introspection">.  This method is useful to
understand the structure of your WSDL: it shows a nested list of
services, bindings, ports and portTypes.

 Option       --Defined in         --Default
 show_declared  XML::Compile::Cache  <true>

. show_declared => BOOLEAN

=back

=head1 DETAILS

=head2 Initializing SOAP operations via WSDL

When you have a WSDL file, then SOAP is simple.  If there is no such file
at hand, then it is still possible to use SOAP.  See the DETAILS chapter
in L<XML::Compile::SOAP|XML::Compile::SOAP>.

The WSDL file contains operations, which can be addressed by name.
In this WSDL file, you need to find the name of the port to be used.
In most cases, the WSDL has only one service, one port, one binding,
and one portType and those names can therefore be omitted.  If there is
a choice, then you are required to select one explicitly.

 use XML::Compile::WSDL11 ();

 # once in your program
 my $wsdl   = XML::Compile::WSDL11->new('def.wsdl');

 # XML::Compile::Schema does not want to follow "include" and
 # "import" commands, so you need to invoke them explicitly.
 # $wsdl->addWSDL('file2.wsdl');            # optional
 # $wsdl->importDefinitions('schema1.xsd'); # optional

 # once for each of the defined operations
 my $call   = $wsdl->compileClient('GetStockPrice');

 # see XML::Compile::SOAP chapter DETAILS about call params
 my $answer = $call->(%request);

=head1 SEE ALSO

This module is part of XML-Compile-SOAP distribution version 2.11,
built on March 02, 2010. Website: F<http://perl.overmeer.net/xml-compile/>

All modules in this suite:
L<XML::Compile>,
L<XML::Compile::SOAP>,
L<XML::Compile::SOAP12>,
L<XML::Compile::SOAP::Daemon>,
L<XML::Compile::Tester>,
L<XML::Compile::Cache>,
L<XML::Compile::Dumper>,
L<XML::Compile::RPC>,
and
L<XML::Rewrite>,
L<XML::ExistDB>,
L<XML::LibXML::Simple>.

Please post questions or ideas to the mailinglist at
F<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/xml-compile>
For life contact with other developers, visit the C<#xml-compile> channel
on C<irc.perl.org>.

=head1 LICENSE

Copyrights 2007-2010 by Mark Overmeer. For other contributors see ChangeLog.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See F<http://www.perl.com/perl/misc/Artistic.html>

